@page "/counter"
@rendermode InteractiveServer
@using System.Diagnostics
@using System.Diagnostics.Metrics
@using System.Text.Json
@inject ILogger<Counter> Logger
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<PageTitle>Counter</PageTitle>

<h1>Counter</h1>

@if (!_isInitialized)
{
    <p><em>Loading saved data...</em></p>
}
else
{
    <p role="status">Current count: @currentCount</p>

    <button class="btn btn-primary" @onclick="IncrementCount">Click me</button>

    <button class="btn btn-primary" @onclick="SlowlyIncrement" disabled="@isIncrementing">
        Slow Increment (Random between 100-900, **FAIR TOSS**)
    </button>

    <button class="btn btn-secondary ms-2" @onclick="ToggleUnattendedMode" disabled="@isIncrementing">
        @(isUnattendedMode ? "Stop Unattended Mode" : "Start Unattended Mode")
    </button>

    @if (isIncrementing)
    {
        <p>
            Incrementing by a random number... (Random between a hundred and nine hundred)
            @if (incrementBy != 0)
            {
                <span>currently, @incrementBy</span>
            }
        </p>
    }

    @if (isUnattendedMode)
    {
        <div class="alert alert-info mt-2">
            <strong>Unattended Mode Active</strong> - Automatically tossing...
        </div>
    }

    @if (historical.Count > 0)
    {
        <h3>Historical Increments (This Session):</h3>

        <table class="table">
            <thead>
                <tr>
                    <th>Increment Value</th>
                    <th>Result</th>
                    <th>Running Total</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var toss in historical)
                {
                    <tr class="@toss.CssClass">
                        <td>@toss.Value</td>
                        <td>@toss.Status</td>
                        <td>@toss.RunningTotal</td>
                    </tr>
                }
            </tbody>
        </table>

        <p><strong>Session Stats:</strong></p>
        <p>Wins: @totalWins</p>
        <p>Losses: @(historical.Count - totalWins)</p>
        <p>Tosses: @historical.Count</p>
    }

    @if (persistedStats != null)
    {
        <div class="mt-4 p-3 border rounded">
            <h3>Lifetime Statistics</h3>
            <p><strong>Total Tosses:</strong> @persistedStats.TotalTosses</p>
            <p><strong>Total Wins:</strong> @persistedStats.TotalWins</p>
            <p><strong>Total Losses:</strong> @persistedStats.TotalLosses</p>
            <p><strong>Win Rate:</strong> @(persistedStats.TotalTosses > 0 ? $"{(double)persistedStats.TotalWins / persistedStats.TotalTosses:P1}" : "N/A")</p>
            <p><strong>Highest Single Toss:</strong> @persistedStats.HighestTossValue</p>
            <p><strong>Lowest Single Toss:</strong> @(persistedStats.LowestTossValue == int.MaxValue ? "N/A" : persistedStats.LowestTossValue.ToString())</p>
            <p><strong>First Played:</strong> @persistedStats.FirstPlayedUtc.ToLocalTime().ToString("g")</p>
            <p><strong>Last Played:</strong> @persistedStats.LastPlayedUtc.ToLocalTime().ToString("g")</p>
            <button class="btn btn-outline-danger btn-sm" @onclick="ClearPersistedStats">Clear History</button>
        </div>
    }
}

@code {
    // ═══════════════════════════════════════════════════════════════════════════
    // LOCAL STORAGE KEY CONSTANTS
    // ═══════════════════════════════════════════════════════════════════════════
    
    // Namespaced to avoid collisions with StateCompare/CountryCompare
    private const string LocalStorageKey = "HelloAspDotnetTen.Counter.Stats";

    // ═══════════════════════════════════════════════════════════════════════════
    // OPENTELEMETRY INSTRUMENTATION
    // ═══════════════════════════════════════════════════════════════════════════

    // ActivitySource for distributed tracing (spans)
    private static readonly ActivitySource ActivitySource = new("BlazorApp.Counter", "1.0.0");

    // Meter for metrics
    private static readonly Meter Meter = new("BlazorApp.Counter", "1.0.0");

    // ── Counters ──────────────────────────────────────────────────────────────
    private static readonly Counter<long> ClickCounter = Meter.CreateCounter<long>(
        "counter.clicks",
        unit: "{clicks}",
        description: "Total number of simple increment clicks");

    private static readonly Counter<long> TossCounter = Meter.CreateCounter<long>(
        "counter.tosses",
        unit: "{tosses}",
        description: "Total number of slow increments (tosses)");

    private static readonly Counter<long> UnattendedTossCounter = Meter.CreateCounter<long>(
        "counter.unattended_tosses",
        unit: "{tosses}",
        description: "Number of tosses made in unattended mode");

    private static readonly Counter<long> LocalStorageLoadCounter = Meter.CreateCounter<long>(
        "counter.localstorage_loads",
        unit: "operations",
        description: "Local storage load operations");

    private static readonly Counter<long> LocalStorageSaveCounter = Meter.CreateCounter<long>(
        "counter.localstorage_saves",
        unit: "operations",
        description: "Local storage save operations");

    private static readonly Counter<long> LocalStorageClearCounter = Meter.CreateCounter<long>(
        "counter.localstorage_clears",
        unit: "operations",
        description: "Local storage clear operations");

    // ── Histograms ────────────────────────────────────────────────────────────
    private static readonly Histogram<int> TossValueHistogram = Meter.CreateHistogram<int>(
        "counter.toss_value",
        unit: "{value}",
        description: "Distribution of toss values");

    // ── UpDownCounters (Gauges) ───────────────────────────────────────────────
    private static readonly UpDownCounter<int> CurrentCountGauge = Meter.CreateUpDownCounter<int>(
        "counter.current_count",
        unit: "{count}",
        description: "Current counter value");

    private static readonly UpDownCounter<int> UnattendedModeActive = Meter.CreateUpDownCounter<int>(
        "counter.unattended_mode_active",
        unit: "{boolean}",
        description: "Whether unattended mode is currently active (1=active, 0=inactive)");

    // ═══════════════════════════════════════════════════════════════════════════
    // COMPONENT STATE
    // ═══════════════════════════════════════════════════════════════════════════

    // Session state (restored from localStorage)
    private int currentCount = 0;
    private List<TossResult> historical = new();
    private int totalWins => GetWinCount(historical.Select(t => t.Value).ToList(), WinThreshold);

    // UI state
    private bool isIncrementing = false;
    private int incrementBy = 0;
    private bool isUnattendedMode = false;
    private CancellationTokenSource? unattendedCts;

    // Local storage state
    private CounterPersistedStats? persistedStats;
    private bool isJsRuntimeAvailable = false;
    private bool _isInitialized = false; // NEW: Track if we've loaded from storage

    // Constants
    private const int WinThreshold = 500;
    private const int DelayMilliseconds = 1;

    // ═══════════════════════════════════════════════════════════════════════════
    // PERSISTED STATS MODEL - NOW INCLUDES SESSION STATE
    // ═══════════════════════════════════════════════════════════════════════════
    private class CounterPersistedStats
    {
        // Lifetime stats
        public int TotalTosses { get; set; }
        public int TotalWins { get; set; }
        public int TotalLosses { get; set; }
        public int HighestTossValue { get; set; }
        public int LowestTossValue { get; set; } = int.MaxValue;
        public DateTime FirstPlayedUtc { get; set; } = DateTime.UtcNow;
        public DateTime LastPlayedUtc { get; set; } = DateTime.UtcNow;

        // SESSION STATE - survives page reload
        public int CurrentCount { get; set; }
        public List<TossResultDto> Historical { get; set; } = new();
    }

    // DTO for serialization (TossResult has computed properties)
    private class TossResultDto
    {
        public int Value { get; set; }
        public string Status { get; set; } = string.Empty;
        public string CssClass { get; set; } = string.Empty;
        public int RunningTotal { get; set; }
    }

    private class TossResult
    {
        public int Value { get; set; }
        public string Status { get; set; } = string.Empty;
        public string CssClass { get; set; } = string.Empty;
        public int RunningTotal { get; set; }

        public TossResultDto ToDto() => new()
        {
            Value = Value,
            Status = Status,
            CssClass = CssClass,
            RunningTotal = RunningTotal
        };

        public static TossResult FromDto(TossResultDto dto) => new()
        {
            Value = dto.Value,
            Status = dto.Status,
            CssClass = dto.CssClass,
            RunningTotal = dto.RunningTotal
        };
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // LIFECYCLE METHODS - FIXED ORDER
    // ═══════════════════════════════════════════════════════════════════════════
    
    // CRITICAL FIX: Don't initialize game state until after localStorage loads
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            using var activity = ActivitySource.StartActivity("Counter.OnAfterRenderAsync.FirstRender");
            
            isJsRuntimeAvailable = true;
            await LoadPersistedStatsAsync(); // Load FIRST
            
            // Restore session state from localStorage
            if (persistedStats != null)
            {
                currentCount = persistedStats.CurrentCount;
                historical = persistedStats.Historical.Select(TossResult.FromDto).ToList();
                
                // Sync gauge to restored value
                CurrentCountGauge.Add(currentCount);
                
                Logger.LogInformation(
                    "Restored session state: CurrentCount={Count}, Historical={HistoricalCount}",
                    currentCount, historical.Count);
            }
            
            _isInitialized = true; // Mark as ready
            activity?.SetTag("storage.loaded", persistedStats != null);
            activity?.SetTag("current_count_restored", currentCount);
            activity?.SetTag("historical_count_restored", historical.Count);
            
            StateHasChanged();
        }
    }

    public async ValueTask DisposeAsync()
    {
        using var activity = ActivitySource.StartActivity("Counter.DisposeAsync");
        
        if (isUnattendedMode)
        {
            activity?.SetTag("unattended.was_active", true);
            await StopUnattendedModeAsync();
        }
        
        // Final save before disposal
        await SavePersistedStatsAsync();
        
        activity?.SetTag("disposed", true);
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // LOCAL STORAGE OPERATIONS - SAVE EVERYTHING
    // ═══════════════════════════════════════════════════════════════════════════
    
    private async Task LoadPersistedStatsAsync()
    {
        using var activity = ActivitySource.StartActivity("Counter.LoadPersistedStats");

        try
        {
            var json = await JSRuntime.InvokeAsync<string?>("localStorage.getItem", LocalStorageKey);

            if (!string.IsNullOrEmpty(json))
            {
                persistedStats = JsonSerializer.Deserialize<CounterPersistedStats>(json);
                LocalStorageLoadCounter.Add(1, new KeyValuePair<string, object?>("storage.found", true));

                activity?.SetTag("storage.found", true);
                activity?.SetTag("storage.total_tosses", persistedStats?.TotalTosses ?? 0);
                activity?.SetTag("storage.current_count", persistedStats?.CurrentCount ?? 0);
                activity?.SetTag("storage.historical_count", persistedStats?.Historical?.Count ?? 0);

                Logger.LogInformation(
                    "Loaded Counter stats: TotalTosses={Total}, CurrentCount={Current}, Historical={Historical}",
                    persistedStats?.TotalTosses ?? 0,
                    persistedStats?.CurrentCount ?? 0,
                    persistedStats?.Historical?.Count ?? 0);
            }
            else
            {
                // Initialize fresh stats
                persistedStats = new CounterPersistedStats();
                await SavePersistedStatsAsync();
                LocalStorageLoadCounter.Add(1, new KeyValuePair<string, object?>("storage.found", false));

                activity?.SetTag("storage.found", false);
            }
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to load Counter persisted stats");
            persistedStats = new CounterPersistedStats();
        }
    }

    private async Task SavePersistedStatsAsync()
    {
        if (!isJsRuntimeAvailable || persistedStats == null) return;

        using var activity = ActivitySource.StartActivity("Counter.SavePersistedStats");

        try
        {
            // Update session state
            persistedStats.CurrentCount = currentCount;
            persistedStats.Historical = historical.Select(h => h.ToDto()).ToList();
            persistedStats.LastPlayedUtc = DateTime.UtcNow;

            var json = JsonSerializer.Serialize(persistedStats);
            await JSRuntime.InvokeVoidAsync("localStorage.setItem", LocalStorageKey, json);

            LocalStorageSaveCounter.Add(1);
            activity?.SetTag("storage.bytes", json.Length);
            activity?.SetTag("storage.tosses_saved", persistedStats.TotalTosses);
            activity?.SetTag("storage.current_count_saved", persistedStats.CurrentCount);
            activity?.SetTag("storage.historical_count_saved", persistedStats.Historical.Count);

            Logger.LogDebug("Saved Counter stats: {Bytes} bytes", json.Length);
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to save Counter persisted stats");
        }
    }

    private async Task ClearPersistedStats()
    {
        using var activity = ActivitySource.StartActivity("Counter.ClearPersistedStats");

        try
        {
            await JSRuntime.InvokeVoidAsync("localStorage.removeItem", LocalStorageKey);

            // Reset gauges
            CurrentCountGauge.Add(-currentCount);

            // Reset all state
            currentCount = 0;
            historical.Clear();
            persistedStats = new CounterPersistedStats();

            await SavePersistedStatsAsync();
            LocalStorageClearCounter.Add(1);

            activity?.SetTag("cleared", true);
            Logger.LogInformation("Cleared Counter persisted stats");

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to clear Counter persisted stats");
        }
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // GAME LOGIC
    // ═══════════════════════════════════════════════════════════════════════════

    private void IncrementCount()
    {
        using var activity = ActivitySource.StartActivity("Counter.IncrementCount");
        
        currentCount++;
        ClickCounter.Add(1);
        CurrentCountGauge.Add(1);
        
        activity?.SetTag("new_count", currentCount);
        
        Logger.LogDebug("Simple increment: currentCount={Count}", currentCount);
        
        // Save immediately
        _ = SavePersistedStatsAsync();
    }

    private async Task SlowlyIncrement()
    {
        using var activity = ActivitySource.StartActivity("Counter.SlowlyIncrement");
        
        isIncrementing = true;
        int targetIncrement;

        // Generate fair toss value (100-900, excluding exactly 500)
        do
        {
            targetIncrement = Random.Shared.Next(100, 901);
        } while (targetIncrement == WinThreshold);

        incrementBy = 0;

        // Animate the increment
        while (incrementBy < targetIncrement)
        {
            incrementBy++;
            currentCount++;
            CurrentCountGauge.Add(1);
            await Task.Delay(DelayMilliseconds);
            await InvokeAsync(StateHasChanged);
        }

        // Record the result
        bool isWin = targetIncrement > WinThreshold;
        var tossResult = new TossResult
        {
            Value = targetIncrement,
            Status = isWin ? "You won a toss" : "You lost a toss",
            CssClass = isWin ? "win-toss" : "lost-toss",
            RunningTotal = currentCount
        };

        historical.Add(tossResult);

        // Update telemetry
        TossCounter.Add(1, new KeyValuePair<string, object?>("result", isWin ? "win" : "loss"));
        TossValueHistogram.Record(targetIncrement);

        // Update lifetime stats
        if (persistedStats != null)
        {
            persistedStats.TotalTosses++;
            if (isWin) persistedStats.TotalWins++; else persistedStats.TotalLosses++;
            if (targetIncrement > persistedStats.HighestTossValue)
                persistedStats.HighestTossValue = targetIncrement;
            if (targetIncrement < persistedStats.LowestTossValue)
                persistedStats.LowestTossValue = targetIncrement;
            if (persistedStats.TotalTosses == 1)
                persistedStats.FirstPlayedUtc = DateTime.UtcNow;
        }

        activity?.SetTag("toss_value", targetIncrement);
        activity?.SetTag("is_win", isWin);
        activity?.SetTag("running_total", currentCount);

        Logger.LogInformation(
            "Toss completed: Value={Value}, Win={Win}, RunningTotal={Total}",
            targetIncrement, isWin, currentCount);

        // Save immediately (no pooling)
        await SavePersistedStatsAsync();

        isIncrementing = false;
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // UNATTENDED MODE
    // ═══════════════════════════════════════════════════════════════════════════

    private async Task ToggleUnattendedMode()
    {
        if (isUnattendedMode)
        {
            await StopUnattendedModeAsync();
        }
        else
        {
            await StartUnattendedModeAsync();
        }
    }

    private async Task StartUnattendedModeAsync()
    {
        using var activity = ActivitySource.StartActivity("Counter.StartUnattendedMode");
        
        isUnattendedMode = true;
        UnattendedModeActive.Add(1);
        unattendedCts = new CancellationTokenSource();
        
        activity?.SetTag("unattended.started", true);
        Logger.LogInformation("Unattended mode started");
        
        _ = RunUnattendedLoopAsync(unattendedCts.Token);
    }

    private async Task StopUnattendedModeAsync()
    {
        using var activity = ActivitySource.StartActivity("Counter.StopUnattendedMode");
        
        if (unattendedCts != null)
        {
            unattendedCts.Cancel();
            unattendedCts.Dispose();
            unattendedCts = null;
        }
        
        isUnattendedMode = false;
        UnattendedModeActive.Add(-1);
        
        activity?.SetTag("unattended.stopped", true);
        Logger.LogInformation("Unattended mode stopped");
    }

    private async Task RunUnattendedLoopAsync(CancellationToken ct)
    {
        using var activity = ActivitySource.StartActivity("Counter.UnattendedLoop");
        int unattendedCount = 0;
        
        try
        {
            while (!ct.IsCancellationRequested)
            {
                // Wait until not incrementing
                while (isIncrementing && !ct.IsCancellationRequested)
                {
                    await Task.Delay(50, ct);
                }
                
                if (ct.IsCancellationRequested) break;
                
                // Small delay before next toss
                await Task.Delay(100, ct);
                
                if (ct.IsCancellationRequested) break;
                
                // Trigger toss
                UnattendedTossCounter.Add(1);
                unattendedCount++;
                await SlowlyIncrement();
            }
        }
        catch (OperationCanceledException)
        {
            // Expected when stopping
        }
        finally
        {
            activity?.SetTag("unattended.tosses", unattendedCount);
            Logger.LogInformation("Unattended loop completed: {Count} tosses", unattendedCount);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // HELPER METHODS
    // ═══════════════════════════════════════════════════════════════════════════

    private static int GetWinCount(List<int> tosses, int threshold)
    {
        return tosses.Count(t => t > threshold);
    }
}
