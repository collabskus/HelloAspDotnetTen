@page "/counter"
@using System.Diagnostics
@using System.Diagnostics.Metrics
@using System.Text.Json
@rendermode InteractiveServer
@inject ILogger<Counter> Logger
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<PageTitle>Counter</PageTitle>

<h1>Counter</h1>

<p role="status">Current count: @currentCount</p>

<button class="btn btn-primary" @onclick="IncrementCount">Click me</button>

<button class="btn btn-primary" @onclick="SlowlyIncrement" disabled="@isIncrementing" id="slowly-increment-jsdlfasjlfjsl">
    Slow Increment (Random between a hundred and nine hundred, **FAIR TOSS**)
</button>

<button class="btn @(isUnattendedMode ? "btn-danger" : "btn-secondary")" @onclick="ToggleUnattendedMode">
    @(isUnattendedMode ? "⏹ Stop Unattended" : "▶ Start Unattended")
</button>

@if (isUnattendedMode)
{
    <p class="text-info">Unattended mode: @unattendedTossCount tosses this session</p>
}

<hr />

<h3>Session Results</h3>
<p>
    Total wins: <span class="win-toss">@totalWins</span> |
    Total losses: <span class="lost-toss">@(historical.Count - totalWins)</span> |
    Win rate: @(historical.Count > 0 ? $"{(double)totalWins / historical.Count:P1}" : "N/A")
</p>

@if (historical.Any())
{
    <div class="historical-results">
        @foreach (var result in historical.AsEnumerable().Reverse().Take(50))
        {
            <span class="@result.CssClass" title="@result.Status">@result.Value</span>
        }
        @if (historical.Count > 50)
        {
            <span class="text-muted">... and @(historical.Count - 50) more</span>
        }
    </div>
}

<hr />

<h3>Lifetime Statistics</h3>
@if (persistedStats != null)
{
    <ul>
        <li>Total tosses: @persistedStats.TotalTosses</li>
        <li>Total wins: @persistedStats.TotalWins (@(persistedStats.TotalTosses > 0 ? $"{(double)persistedStats.TotalWins / persistedStats.TotalTosses:P1}" : "N/A"))</li>
        <li>Total losses: @persistedStats.TotalLosses</li>
        <li>Highest toss: @persistedStats.HighestTossValue</li>
        <li>Lowest toss: @(persistedStats.LowestTossValue == int.MaxValue ? "N/A" : persistedStats.LowestTossValue)</li>
        <li>First played: @persistedStats.FirstPlayedUtc.ToLocalTime().ToString("g")</li>
        <li>Last played: @persistedStats.LastPlayedUtc.ToLocalTime().ToString("g")</li>
    </ul>

    <button class="btn btn-outline-danger btn-sm" @onclick="ClearPersistedStats">Clear Lifetime Stats</button>
}
else
{
    <p class="text-muted">Loading statistics...</p>
}

@if (!string.IsNullOrEmpty(_storageWarning))
{
    <div class="alert alert-warning mt-3">
        <strong>Storage Notice:</strong> @_storageWarning
    </div>
}

@code {
    // ═══════════════════════════════════════════════════════════════════════════
    // CONSTANTS
    // ═══════════════════════════════════════════════════════════════════════════
    
    private const string LocalStorageKey = "HelloAspDotnetTen.Counter.Stats";
    private const string BackupStorageKey = "HelloAspDotnetTen.Counter.Stats.Backup";
    private const int WinThreshold = 500;
    private const int DelayMilliseconds = 1;
    private const int MaxHistoricalEntries = 500; // Prevent unbounded growth

    // ═══════════════════════════════════════════════════════════════════════════
    // OPENTELEMETRY INSTRUMENTATION
    // ═══════════════════════════════════════════════════════════════════════════

    private static readonly ActivitySource ActivitySource = new("BlazorApp.Counter", "1.0.0");
    private static readonly Meter Meter = new("BlazorApp.Counter", "1.0.0");

    private static readonly Counter<long> ClickCounter = Meter.CreateCounter<long>(
        "counter.clicks", unit: "clicks", description: "Number of button clicks");
    private static readonly Counter<long> TossCounter = Meter.CreateCounter<long>(
        "counter.tosses", unit: "tosses", description: "Number of slow increment tosses");
    private static readonly Counter<long> WinCounter = Meter.CreateCounter<long>(
        "counter.wins", unit: "wins", description: "Number of winning tosses");
    private static readonly Counter<long> LossCounter = Meter.CreateCounter<long>(
        "counter.losses", unit: "losses", description: "Number of losing tosses");
    private static readonly Counter<long> UnattendedTossCounter = Meter.CreateCounter<long>(
        "counter.unattended_tosses", unit: "tosses", description: "Tosses in unattended mode");
    private static readonly Counter<long> LocalStorageLoadCounter = Meter.CreateCounter<long>(
        "counter.localstorage_loads", unit: "operations", description: "Local storage load ops");
    private static readonly Counter<long> LocalStorageSaveCounter = Meter.CreateCounter<long>(
        "counter.localstorage_saves", unit: "operations", description: "Local storage save ops");
    private static readonly Counter<long> LocalStorageClearCounter = Meter.CreateCounter<long>(
        "counter.localstorage_clears", unit: "operations", description: "Local storage clear ops");
    private static readonly Counter<long> StorageRecoveryCounter = Meter.CreateCounter<long>(
        "counter.storage_recoveries", unit: "recoveries", description: "Data recovered from backup");
    private static readonly Counter<long> StorageCorruptionCounter = Meter.CreateCounter<long>(
        "counter.storage_corruptions", unit: "corruptions", description: "Corrupted data detected");

    private static readonly Histogram<int> TossValueHistogram = Meter.CreateHistogram<int>(
        "counter.toss_value", unit: "{value}", description: "Distribution of toss values (100-900)");
    private static readonly Histogram<double> TossDurationHistogram = Meter.CreateHistogram<double>(
        "counter.toss_duration", unit: "ms", description: "Duration of slow increment operations");

    private static readonly UpDownCounter<int> CurrentCountGauge = Meter.CreateUpDownCounter<int>(
        "counter.current_value", unit: "{count}", description: "Current counter value");
    private static readonly UpDownCounter<int> UnattendedModeGauge = Meter.CreateUpDownCounter<int>(
        "counter.unattended_mode_active", unit: "{active}", description: "Unattended mode active (1/0)");

    // ═══════════════════════════════════════════════════════════════════════════
    // COMPONENT STATE
    // ═══════════════════════════════════════════════════════════════════════════

    private int currentCount = 0;
    private bool isIncrementing = false;
    private int incrementBy = 0;
    private List<TossResult> historical = new();
    private int totalWins => GetWinCount(historical.Select(t => t.Value).ToList(), WinThreshold);

    private bool isUnattendedMode = false;
    private CancellationTokenSource? unattendedCts;
    private int unattendedTossCount = 0;

    private CounterPersistedStats? persistedStats;
    private bool isJsRuntimeAvailable = false;
    private bool _isInitialized = false;
    private string? _storageWarning;

    // ═══════════════════════════════════════════════════════════════════════════
    // PERSISTED STATS MODEL
    // ═══════════════════════════════════════════════════════════════════════════

    private class CounterPersistedStats
    {
        public int TotalTosses { get; set; }
        public int TotalWins { get; set; }
        public int TotalLosses { get; set; }
        public int HighestTossValue { get; set; }
        public int LowestTossValue { get; set; } = int.MaxValue;
        public DateTime FirstPlayedUtc { get; set; } = DateTime.UtcNow;
        public DateTime LastPlayedUtc { get; set; } = DateTime.UtcNow;
        
        // Session state - also persisted for recovery
        public int CurrentCount { get; set; }
        public List<TossResultDto> Historical { get; set; } = new();
        
        // Integrity check
        public string? Checksum { get; set; }
    }

    private class TossResultDto
    {
        public int Value { get; set; }
        public string Status { get; set; } = string.Empty;
        public string CssClass { get; set; } = string.Empty;
        public int RunningTotal { get; set; }
    }

    private class TossResult
    {
        public int Value { get; set; }
        public string Status { get; set; } = string.Empty;
        public string CssClass { get; set; } = string.Empty;
        public int RunningTotal { get; set; }

        public TossResultDto ToDto() => new()
        {
            Value = Value,
            Status = Status,
            CssClass = CssClass,
            RunningTotal = RunningTotal
        };

        public static TossResult FromDto(TossResultDto dto) => new()
        {
            Value = dto.Value,
            Status = dto.Status,
            CssClass = dto.CssClass,
            RunningTotal = dto.RunningTotal
        };
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // LIFECYCLE METHODS
    // ═══════════════════════════════════════════════════════════════════════════

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            using var activity = ActivitySource.StartActivity("Counter.OnAfterRenderAsync.FirstRender");

            isJsRuntimeAvailable = true;
            await LoadPersistedStatsAsync();

            if (persistedStats != null)
            {
                currentCount = persistedStats.CurrentCount;
                historical = persistedStats.Historical.Select(TossResult.FromDto).ToList();
                CurrentCountGauge.Add(currentCount);

                Logger.LogInformation(
                    "Restored session: CurrentCount={Count}, Historical={HistoricalCount}",
                    currentCount, historical.Count);
            }

            _isInitialized = true;
            activity?.SetTag("storage.loaded", persistedStats != null);
            activity?.SetTag("current_count_restored", currentCount);
            activity?.SetTag("historical_count_restored", historical.Count);

            StateHasChanged();
        }
    }

    public async ValueTask DisposeAsync()
    {
        using var activity = ActivitySource.StartActivity("Counter.DisposeAsync");

        if (isUnattendedMode)
        {
            activity?.SetTag("unattended.was_active", true);
            await StopUnattendedModeAsync();
        }

        await SavePersistedStatsAsync();
        activity?.SetTag("disposed", true);
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // ROBUST LOCAL STORAGE OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════════

    /// <summary>
    /// Calculates a simple checksum for data integrity verification.
    /// </summary>
    private string CalculateChecksum(CounterPersistedStats stats)
    {
        // Simple checksum based on key values - not cryptographic, just integrity check
        var data = $"{stats.TotalTosses}|{stats.TotalWins}|{stats.CurrentCount}|{stats.Historical?.Count ?? 0}";
        var hash = data.GetHashCode();
        return hash.ToString("X8");
    }

    /// <summary>
    /// Validates that JSON is complete and parseable.
    /// </summary>
    private bool TryParseAndValidate(string? json, out CounterPersistedStats? stats, out string? error)
    {
        stats = null;
        error = null;

        if (string.IsNullOrEmpty(json))
        {
            error = "Empty or null JSON";
            return false;
        }

        // Check for obvious truncation (incomplete JSON)
        var trimmed = json.Trim();
        if (!trimmed.EndsWith("}"))
        {
            error = "JSON appears truncated (doesn't end with })";
            return false;
        }

        // Count braces to detect truncation
        int openBraces = json.Count(c => c == '{');
        int closeBraces = json.Count(c => c == '}');
        if (openBraces != closeBraces)
        {
            error = $"JSON brace mismatch: {openBraces} open, {closeBraces} close";
            return false;
        }

        try
        {
            stats = JsonSerializer.Deserialize<CounterPersistedStats>(json);
            if (stats == null)
            {
                error = "Deserialization returned null";
                return false;
            }

            // Validate checksum if present
            if (!string.IsNullOrEmpty(stats.Checksum))
            {
                var expectedChecksum = CalculateChecksum(stats);
                if (stats.Checksum != expectedChecksum)
                {
                    error = $"Checksum mismatch: expected {expectedChecksum}, got {stats.Checksum}";
                    // Don't fail on checksum mismatch - data might still be usable
                    Logger.LogWarning("Checksum mismatch detected but proceeding with data");
                }
            }

            return true;
        }
        catch (JsonException ex)
        {
            error = $"JSON parse error: {ex.Message}";
            return false;
        }
    }

    private async Task LoadPersistedStatsAsync()
    {
        using var activity = ActivitySource.StartActivity("Counter.LoadPersistedStats");

        try
        {
            // Try main key first
            var json = await JSRuntime.InvokeAsync<string?>("localStorage.getItem", LocalStorageKey);

            if (TryParseAndValidate(json, out var stats, out var error))
            {
                persistedStats = stats;
                LocalStorageLoadCounter.Add(1, new KeyValuePair<string, object?>("storage.source", "main"));

                activity?.SetTag("storage.found", true);
                activity?.SetTag("storage.source", "main");
                activity?.SetTag("storage.total_tosses", persistedStats?.TotalTosses ?? 0);

                Logger.LogInformation(
                    "Loaded stats from main storage: TotalTosses={Total}, CurrentCount={Current}, Historical={Historical}",
                    persistedStats?.TotalTosses ?? 0,
                    persistedStats?.CurrentCount ?? 0,
                    persistedStats?.Historical?.Count ?? 0);
                return;
            }

            // Main key failed - log the error
            if (!string.IsNullOrEmpty(json))
            {
                StorageCorruptionCounter.Add(1);
                Logger.LogWarning("Main storage corrupted: {Error}. JSON length: {Length}, First 100 chars: {Preview}",
                    error, json.Length, json.Substring(0, Math.Min(100, json.Length)));
                activity?.SetTag("storage.main_corrupted", true);
                activity?.SetTag("storage.corruption_error", error);
            }

            // Try backup key
            var backupJson = await JSRuntime.InvokeAsync<string?>("localStorage.getItem", BackupStorageKey);

            if (TryParseAndValidate(backupJson, out var backupStats, out var backupError))
            {
                persistedStats = backupStats;
                StorageRecoveryCounter.Add(1);
                LocalStorageLoadCounter.Add(1, new KeyValuePair<string, object?>("storage.source", "backup"));

                _storageWarning = "Recovered data from backup. Some recent progress may have been lost.";

                activity?.SetTag("storage.found", true);
                activity?.SetTag("storage.source", "backup");
                activity?.SetTag("storage.recovered", true);

                Logger.LogWarning(
                    "Recovered from backup: TotalTosses={Total}, CurrentCount={Current}. Main was corrupted.",
                    persistedStats?.TotalTosses ?? 0,
                    persistedStats?.CurrentCount ?? 0);

                // Immediately save to main key to restore it
                await SavePersistedStatsAsync();
                return;
            }

            // Both failed - start fresh
            Logger.LogWarning("Both main and backup storage failed. Starting fresh. Main error: {MainError}, Backup error: {BackupError}",
                error ?? "empty", backupError ?? "empty");

            persistedStats = new CounterPersistedStats();
            await SavePersistedStatsAsync();

            LocalStorageLoadCounter.Add(1, new KeyValuePair<string, object?>("storage.found", false));
            activity?.SetTag("storage.found", false);
            activity?.SetTag("storage.created_new", true);
        }
        catch (Exception ex)
        {
            activity?.SetStatus(ActivityStatusCode.Error, ex.Message);
            Logger.LogError(ex, "Failed to load persisted stats");
            persistedStats = new CounterPersistedStats();
        }
    }

    private async Task SavePersistedStatsAsync()
    {
        if (!isJsRuntimeAvailable || persistedStats == null) return;

        using var activity = ActivitySource.StartActivity("Counter.SavePersistedStats");

        try
        {
            // Update session state
            persistedStats.CurrentCount = currentCount;
            persistedStats.LastPlayedUtc = DateTime.UtcNow;

            // Trim historical to prevent unbounded growth
            if (historical.Count > MaxHistoricalEntries)
            {
                // Keep most recent entries
                historical = historical.Skip(historical.Count - MaxHistoricalEntries).ToList();
                Logger.LogInformation("Trimmed historical entries to {Max}", MaxHistoricalEntries);
            }

            persistedStats.Historical = historical.Select(h => h.ToDto()).ToList();

            // Calculate checksum for integrity verification
            persistedStats.Checksum = CalculateChecksum(persistedStats);

            var json = JsonSerializer.Serialize(persistedStats);

            // Validate our own output before saving
            if (!TryParseAndValidate(json, out _, out var error))
            {
                Logger.LogError("Generated invalid JSON! Error: {Error}", error);
                activity?.SetStatus(ActivityStatusCode.Error, "Generated invalid JSON");
                return;
            }

            // ATOMIC WRITE PATTERN:
            // 1. Save to backup first
            // 2. Verify backup was saved correctly
            // 3. Only then update main key

            // Step 1: Save to backup
            await JSRuntime.InvokeVoidAsync("localStorage.setItem", BackupStorageKey, json);

            // Step 2: Verify backup (read it back)
            var verifyBackup = await JSRuntime.InvokeAsync<string?>("localStorage.getItem", BackupStorageKey);
            if (verifyBackup != json)
            {
                Logger.LogError("Backup verification failed! Expected {Expected} chars, got {Actual} chars",
                    json.Length, verifyBackup?.Length ?? 0);
                activity?.SetStatus(ActivityStatusCode.Error, "Backup verification failed");
                // Don't overwrite main key if backup failed
                return;
            }

            // Step 3: Save to main key (backup is now safe)
            await JSRuntime.InvokeVoidAsync("localStorage.setItem", LocalStorageKey, json);

            LocalStorageSaveCounter.Add(1);
            activity?.SetTag("storage.bytes", json.Length);
            activity?.SetTag("storage.historical_count", persistedStats.Historical.Count);
            activity?.SetTag("storage.checksum", persistedStats.Checksum);
            activity?.SetStatus(ActivityStatusCode.Ok);

            Logger.LogDebug("Saved stats: {Bytes} bytes, {Historical} historical entries, checksum {Checksum}",
                json.Length, persistedStats.Historical.Count, persistedStats.Checksum);
        }
        catch (Exception ex)
        {
            activity?.SetStatus(ActivityStatusCode.Error, ex.Message);
            Logger.LogWarning(ex, "Failed to save persisted stats");
        }
    }

    private async Task ClearPersistedStats()
    {
        using var activity = ActivitySource.StartActivity("Counter.ClearPersistedStats");

        try
        {
            await JSRuntime.InvokeVoidAsync("localStorage.removeItem", LocalStorageKey);
            await JSRuntime.InvokeVoidAsync("localStorage.removeItem", BackupStorageKey);

            persistedStats = new CounterPersistedStats();
            currentCount = 0;
            historical.Clear();
            _storageWarning = null;

            await SavePersistedStatsAsync();

            LocalStorageClearCounter.Add(1);
            activity?.SetStatus(ActivityStatusCode.Ok);

            Logger.LogInformation("Cleared all persisted stats");
            StateHasChanged();
        }
        catch (Exception ex)
        {
            activity?.SetStatus(ActivityStatusCode.Error, ex.Message);
            Logger.LogWarning(ex, "Failed to clear persisted stats");
        }
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // EVENT HANDLERS
    // ═══════════════════════════════════════════════════════════════════════════

    private void IncrementCount()
    {
        using var activity = ActivitySource.StartActivity("Counter.IncrementCount");

        var previousCount = currentCount;
        currentCount++;

        ClickCounter.Add(1);
        CurrentCountGauge.Add(1);

        activity?.SetTag("counter.previous", previousCount);
        activity?.SetTag("counter.current", currentCount);

        Logger.LogDebug("Counter incremented: {Previous} -> {Current}", previousCount, currentCount);
    }

    private async Task SlowlyIncrement()
    {
        if (isIncrementing) return;

        using var activity = ActivitySource.StartActivity("Counter.SlowlyIncrement");
        var stopwatch = Stopwatch.StartNew();

        isIncrementing = true;
        incrementBy = Random.Shared.Next(100, 901);

        activity?.SetTag("toss.value", incrementBy);
        activity?.SetTag("toss.is_win", incrementBy >= WinThreshold);

        TossCounter.Add(1);
        TossValueHistogram.Record(incrementBy);

        if (incrementBy >= WinThreshold)
            WinCounter.Add(1, new KeyValuePair<string, object?>("value", incrementBy));
        else
            LossCounter.Add(1, new KeyValuePair<string, object?>("value", incrementBy));

        var targetCount = currentCount + incrementBy;
        while (currentCount < targetCount)
        {
            currentCount++;
            CurrentCountGauge.Add(1);
            await Task.Delay(DelayMilliseconds);
            StateHasChanged();
        }

        var result = new TossResult
        {
            Value = incrementBy,
            Status = incrementBy >= WinThreshold ? "You won a toss" : "You lost a toss",
            CssClass = incrementBy >= WinThreshold ? "win-toss" : "lost-toss",
            RunningTotal = currentCount
        };
        historical.Add(result);

        // Update lifetime stats
        if (persistedStats != null)
        {
            persistedStats.TotalTosses++;
            if (incrementBy >= WinThreshold)
                persistedStats.TotalWins++;
            else
                persistedStats.TotalLosses++;

            if (incrementBy > persistedStats.HighestTossValue)
                persistedStats.HighestTossValue = incrementBy;
            if (incrementBy < persistedStats.LowestTossValue)
                persistedStats.LowestTossValue = incrementBy;
        }

        await SavePersistedStatsAsync();

        stopwatch.Stop();
        TossDurationHistogram.Record(stopwatch.Elapsed.TotalMilliseconds);

        activity?.SetTag("toss.duration_ms", stopwatch.Elapsed.TotalMilliseconds);
        activity?.SetStatus(ActivityStatusCode.Ok);

        Logger.LogInformation("Toss completed: Value={Value}, Win={IsWin}, Duration={Duration}ms",
            incrementBy, incrementBy >= WinThreshold, stopwatch.Elapsed.TotalMilliseconds);

        isIncrementing = false;
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // UNATTENDED MODE
    // ═══════════════════════════════════════════════════════════════════════════

    private async Task ToggleUnattendedMode()
    {
        if (isUnattendedMode)
            await StopUnattendedModeAsync();
        else
            await StartUnattendedModeAsync();
    }

    private async Task StartUnattendedModeAsync()
    {
        using var activity = ActivitySource.StartActivity("Counter.StartUnattendedMode");

        isUnattendedMode = true;
        unattendedTossCount = 0;
        unattendedCts = new CancellationTokenSource();

        UnattendedModeGauge.Add(1);
        activity?.SetTag("unattended.started", true);

        Logger.LogInformation("Unattended mode started");

        _ = RunUnattendedLoopAsync(unattendedCts.Token);
    }

    private async Task StopUnattendedModeAsync()
    {
        using var activity = ActivitySource.StartActivity("Counter.StopUnattendedMode");

        isUnattendedMode = false;
        unattendedCts?.Cancel();
        unattendedCts?.Dispose();
        unattendedCts = null;

        UnattendedModeGauge.Add(-1);
        activity?.SetTag("unattended.stopped", true);
        activity?.SetTag("unattended.total_tosses", unattendedTossCount);

        Logger.LogInformation("Unattended mode stopped after {TossCount} tosses", unattendedTossCount);

        await SavePersistedStatsAsync();
    }

    private async Task RunUnattendedLoopAsync(CancellationToken cancellationToken)
    {
        using var activity = ActivitySource.StartActivity("Counter.UnattendedLoop");

        try
        {
            while (!cancellationToken.IsCancellationRequested && isUnattendedMode)
            {
                if (!isIncrementing)
                {
                    await SlowlyIncrement();
                    unattendedTossCount++;
                    UnattendedTossCounter.Add(1);
                }

                await Task.Delay(100, cancellationToken);
            }

            activity?.SetTag("unattended.completed_normally", true);
        }
        catch (OperationCanceledException)
        {
            activity?.SetTag("unattended.cancelled", true);
            Logger.LogDebug("Unattended loop cancelled");
        }
        catch (Exception ex)
        {
            activity?.SetStatus(ActivityStatusCode.Error, ex.Message);
            Logger.LogError(ex, "Unattended loop error");
        }

        activity?.SetTag("unattended.total_tosses", unattendedTossCount);
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // HELPER METHODS
    // ═══════════════════════════════════════════════════════════════════════════

    private static int GetWinCount(List<int> values, int threshold) =>
        values.Count(v => v >= threshold);
}
