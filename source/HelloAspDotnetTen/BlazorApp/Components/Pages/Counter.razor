@page "/counter"
@rendermode InteractiveServer
@using System.Diagnostics
@using System.Diagnostics.Metrics
@using System.Text.Json
@inject ILogger<Counter> Logger
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<PageTitle>Counter</PageTitle>

<h1>Counter</h1>

<p role="status">Current count: @currentCount</p>

<button class="btn btn-primary" @onclick="IncrementCount">Click me</button>

<button class="btn btn-primary" @onclick="SlowlyIncrement" disabled="@isIncrementing">
    Slow Increment (Random between 100-900, **FAIR TOSS**)
</button>

<button class="btn btn-secondary ms-2" @onclick="ToggleUnattendedMode" disabled="@isIncrementing">
    @(isUnattendedMode ? "Stop Unattended" : "Start Unattended")
</button>

@if (isIncrementing)
{
    <p>
        Incrementing by a random number... (Random between 100-900)
        @if (incrementBy != 0)
        {
            <span>currently, @incrementBy</span>
        }
    </p>
}

@if (historical.Count > 0)
{
    <h3>Historical Increments:</h3>

    <table class="table">
        <thead>
            <tr>
                <th>Increment Value</th>
                <th>Result</th>
                <th>Running Total</th>
            </tr>
        </thead>
        <tbody>
            @foreach (var toss in historical)
            {
                <tr class="@toss.CssClass">
                    <td>@toss.Value</td>
                    <td>@toss.Status</td>
                    <td>@toss.RunningTotal</td>
                </tr>
            }
        </tbody>
    </table>

    <p>Wins: @totalWins</p>
    <p>Losses: @(historical.Count - totalWins)</p>
    <p>Tosses: @historical.Count</p>
}

@if (persistedStats != null)
{
    <div class="lifetime-stats mt-4 p-3 bg-light rounded">
        <h4>Lifetime Statistics</h4>
        <p>Total Tosses: @persistedStats.TotalTosses</p>
        <p>Total Wins: @persistedStats.TotalWins (@(persistedStats.TotalTosses > 0 ? $"{(double)persistedStats.TotalWins / persistedStats.TotalTosses:P1}" : "N/A"))</p>
        <p>Highest Toss: @(persistedStats.HighestTossValue > 0 ? persistedStats.HighestTossValue.ToString() : "N/A")</p>
        <p>Lowest Toss: @(persistedStats.LowestTossValue < int.MaxValue ? persistedStats.LowestTossValue.ToString() : "N/A")</p>
        <p><small class="text-muted">Playing since: @persistedStats.FirstPlayedUtc.ToLocalTime().ToString("g")</small></p>
        <button class="btn btn-outline-danger btn-sm" @onclick="ClearPersistedStats">Clear All Stats</button>
    </div>
}

@code {
    // ═══════════════════════════════════════════════════════════════════════════
    // LOCAL STORAGE KEY
    // ═══════════════════════════════════════════════════════════════════════════
    private const string LocalStorageKey = "HelloAspDotnetTen.Counter.Stats";

    // ═══════════════════════════════════════════════════════════════════════════
    // OPENTELEMETRY INSTRUMENTATION
    // ═══════════════════════════════════════════════════════════════════════════
    private static readonly ActivitySource ActivitySource = new("BlazorApp.Counter", "1.0.0");
    private static readonly Meter Meter = new("BlazorApp.Counter", "1.0.0");

    private static readonly Counter<long> ClickCounter = Meter.CreateCounter<long>("counter.clicks", "clicks", "Number of simple increment clicks");
    private static readonly Counter<long> TossCounter = Meter.CreateCounter<long>("counter.tosses", "tosses", "Number of slow increment tosses");
    private static readonly Counter<long> WinCounter = Meter.CreateCounter<long>("counter.wins", "wins", "Number of winning tosses");
    private static readonly Counter<long> LossCounter = Meter.CreateCounter<long>("counter.losses", "losses", "Number of losing tosses");
    private static readonly Histogram<int> TossValueHistogram = Meter.CreateHistogram<int>("counter.toss_value", "value", "Distribution of toss values");
    private static readonly Histogram<double> TossDurationHistogram = Meter.CreateHistogram<double>("counter.toss_duration", "ms", "Duration of slow increment");
    private static readonly UpDownCounter<int> CurrentValueGauge = Meter.CreateUpDownCounter<int>("counter.current_value", "count", "Current counter value");
    private static readonly Counter<long> LocalStorageLoadCounter = Meter.CreateCounter<long>("counter.storage.loads", "operations", "Local storage load operations");
    private static readonly Counter<long> LocalStorageSaveCounter = Meter.CreateCounter<long>("counter.storage.saves", "operations", "Local storage save operations");
    private static readonly Counter<long> LocalStorageClearCounter = Meter.CreateCounter<long>("counter.storage.clears", "operations", "Local storage clear operations");

    // ═══════════════════════════════════════════════════════════════════════════
    // GAME STATE - ALL PERSISTED TO LOCAL STORAGE
    // ═══════════════════════════════════════════════════════════════════════════
    private int currentCount = 0;
    private bool isIncrementing = false;
    private int incrementBy = 0;
    private List<TossResult> historical = new();
    private int totalWins => GetWinCount(historical.Select(t => t.Value).ToList(), WinThreshold);

    private const int WinThreshold = 500;
    private const int DelayMilliseconds = 1;

    // Unattended mode
    private bool isUnattendedMode = false;
    private CancellationTokenSource? unattendedCts;

    // Local storage state
    private CounterPersistedStats? persistedStats;
    private bool isJsRuntimeAvailable = false;

    // ═══════════════════════════════════════════════════════════════════════════
    // PERSISTED STATS MODEL - NOW INCLUDES SESSION STATE
    // ═══════════════════════════════════════════════════════════════════════════
    private class CounterPersistedStats
    {
        // Lifetime stats
        public int TotalTosses { get; set; }
        public int TotalWins { get; set; }
        public int TotalLosses { get; set; }
        public int HighestTossValue { get; set; }
        public int LowestTossValue { get; set; } = int.MaxValue;
        public DateTime FirstPlayedUtc { get; set; } = DateTime.UtcNow;
        public DateTime LastPlayedUtc { get; set; } = DateTime.UtcNow;

        // SESSION STATE - survives page reload
        public int CurrentCount { get; set; }
        public List<TossResultDto> Historical { get; set; } = new();
    }

    // DTO for serialization (TossResult has computed properties)
    private class TossResultDto
    {
        public int Value { get; set; }
        public string Status { get; set; } = string.Empty;
        public string CssClass { get; set; } = string.Empty;
        public int RunningTotal { get; set; }
    }

    private class TossResult
    {
        public int Value { get; set; }
        public string Status { get; set; } = string.Empty;
        public string CssClass { get; set; } = string.Empty;
        public int RunningTotal { get; set; }

        public TossResultDto ToDto() => new()
        {
            Value = Value,
            Status = Status,
            CssClass = CssClass,
            RunningTotal = RunningTotal
        };

        public static TossResult FromDto(TossResultDto dto) => new()
        {
            Value = dto.Value,
            Status = dto.Status,
            CssClass = dto.CssClass,
            RunningTotal = dto.RunningTotal
        };
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // LIFECYCLE METHODS
    // ═══════════════════════════════════════════════════════════════════════════
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            using var activity = ActivitySource.StartActivity("Counter.OnAfterRenderAsync.FirstRender");
            isJsRuntimeAvailable = true;
            await LoadPersistedStatsAsync();
            activity?.SetTag("storage.loaded", persistedStats != null);
            StateHasChanged();
        }
    }

    public async ValueTask DisposeAsync()
    {
        using var activity = ActivitySource.StartActivity("Counter.DisposeAsync");
        if (isUnattendedMode)
        {
            await StopUnattendedModeAsync();
        }
        // Final save on dispose
        await SavePersistedStatsAsync();
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // LOCAL STORAGE OPERATIONS - SAVE EVERYTHING
    // ═══════════════════════════════════════════════════════════════════════════
    private async Task LoadPersistedStatsAsync()
    {
        using var activity = ActivitySource.StartActivity("Counter.LoadPersistedStats");

        try
        {
            var json = await JSRuntime.InvokeAsync<string?>("localStorage.getItem", LocalStorageKey);

            if (!string.IsNullOrEmpty(json))
            {
                persistedStats = JsonSerializer.Deserialize<CounterPersistedStats>(json);
                LocalStorageLoadCounter.Add(1, new KeyValuePair<string, object?>("storage.found", true));

                // RESTORE SESSION STATE
                if (persistedStats != null)
                {
                    currentCount = persistedStats.CurrentCount;
                    historical = persistedStats.Historical.Select(TossResult.FromDto).ToList();
                    CurrentValueGauge.Add(currentCount); // Sync gauge
                }

                Logger.LogInformation(
                    "Loaded persisted stats: TotalTosses={TotalTosses}, CurrentCount={CurrentCount}, Historical={HistoricalCount}",
                    persistedStats?.TotalTosses ?? 0, persistedStats?.CurrentCount ?? 0, persistedStats?.Historical?.Count ?? 0);
            }
            else
            {
                persistedStats = new CounterPersistedStats();
                await SavePersistedStatsAsync();
                LocalStorageLoadCounter.Add(1, new KeyValuePair<string, object?>("storage.found", false));
            }
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to load persisted stats");
            persistedStats = new CounterPersistedStats();
        }
    }

    private async Task SavePersistedStatsAsync()
    {
        if (!isJsRuntimeAvailable || persistedStats == null) return;

        using var activity = ActivitySource.StartActivity("Counter.SavePersistedStats");

        try
        {
            // SAVE SESSION STATE
            persistedStats.CurrentCount = currentCount;
            persistedStats.Historical = historical.Select(h => h.ToDto()).ToList();
            persistedStats.LastPlayedUtc = DateTime.UtcNow;

            var json = JsonSerializer.Serialize(persistedStats);
            await JSRuntime.InvokeVoidAsync("localStorage.setItem", LocalStorageKey, json);

            LocalStorageSaveCounter.Add(1);
            activity?.SetTag("storage.bytes", json.Length);
            Logger.LogDebug("Saved persisted stats: Count={Count}, Historical={HistoricalCount}", currentCount, historical.Count);
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to save persisted stats");
        }
    }

    private async Task ClearPersistedStats()
    {
        using var activity = ActivitySource.StartActivity("Counter.ClearPersistedStats");

        try
        {
            await JSRuntime.InvokeVoidAsync("localStorage.removeItem", LocalStorageKey);

            // Reset everything
            currentCount = 0;
            historical.Clear();
            CurrentValueGauge.Add(-currentCount);
            persistedStats = new CounterPersistedStats();
            await SavePersistedStatsAsync();

            LocalStorageClearCounter.Add(1);
            Logger.LogInformation("Cleared all persisted stats");
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to clear persisted stats");
        }
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // EVENT HANDLERS
    // ═══════════════════════════════════════════════════════════════════════════
    private async Task IncrementCount()
    {
        using var activity = ActivitySource.StartActivity("Counter.IncrementCount");

        var previousValue = currentCount;
        currentCount++;
        CurrentValueGauge.Add(1);
        ClickCounter.Add(1);

        activity?.SetTag("counter.previous", previousValue);
        activity?.SetTag("counter.new", currentCount);

        // Save immediately
        await SavePersistedStatsAsync();
    }

    private async Task SlowlyIncrement()
    {
        using var activity = ActivitySource.StartActivity("Counter.SlowlyIncrement");
        var stopwatch = Stopwatch.StartNew();

        int targetIncrement;
        do
        {
            targetIncrement = Random.Shared.Next(100, 901);
        } while (targetIncrement == WinThreshold);

        incrementBy = targetIncrement;
        TossCounter.Add(1);
        TossValueHistogram.Record(targetIncrement);

        activity?.SetTag("toss.value", targetIncrement);
        activity?.SetTag("toss.is_win", targetIncrement > WinThreshold);

        string status = targetIncrement > WinThreshold ? "You won a toss" : "You lost a toss";
        string cssClass = targetIncrement > WinThreshold ? "win-toss" : "lost-toss";
        int runningTotal = currentCount + targetIncrement;

        historical.Add(new TossResult
        {
            Value = targetIncrement,
            Status = status,
            CssClass = cssClass,
            RunningTotal = runningTotal
        });

        // Update lifetime stats
        if (persistedStats != null)
        {
            persistedStats.TotalTosses++;
            if (targetIncrement > WinThreshold)
            {
                persistedStats.TotalWins++;
                WinCounter.Add(1, new KeyValuePair<string, object?>("value", targetIncrement));
            }
            else
            {
                persistedStats.TotalLosses++;
                LossCounter.Add(1, new KeyValuePair<string, object?>("value", targetIncrement));
            }
            if (targetIncrement > persistedStats.HighestTossValue)
                persistedStats.HighestTossValue = targetIncrement;
            if (targetIncrement < persistedStats.LowestTossValue)
                persistedStats.LowestTossValue = targetIncrement;
        }

        isIncrementing = true;
        StateHasChanged();

        for (int i = 0; i < targetIncrement; i++)
        {
            currentCount++;
            CurrentValueGauge.Add(1);
            await Task.Delay(DelayMilliseconds);
            await InvokeAsync(StateHasChanged);
        }

        stopwatch.Stop();
        TossDurationHistogram.Record(stopwatch.Elapsed.TotalMilliseconds);
        activity?.SetTag("toss.duration_ms", stopwatch.Elapsed.TotalMilliseconds);

        isIncrementing = false;

        // Save after every toss
        await SavePersistedStatsAsync();
        StateHasChanged();
    }

    private async Task ToggleUnattendedMode()
    {
        if (isUnattendedMode)
        {
            await StopUnattendedModeAsync();
        }
        else
        {
            await StartUnattendedModeAsync();
        }
    }

    private async Task StartUnattendedModeAsync()
    {
        isUnattendedMode = true;
        unattendedCts = new CancellationTokenSource();

        _ = Task.Run(async () =>
        {
            while (!unattendedCts.Token.IsCancellationRequested)
            {
                await InvokeAsync(async () =>
                {
                    if (!isIncrementing)
                    {
                        await SlowlyIncrement();
                    }
                });
                await Task.Delay(100, unattendedCts.Token).ConfigureAwait(false);
            }
        }, unattendedCts.Token);

        await Task.CompletedTask;
    }

    private async Task StopUnattendedModeAsync()
    {
        isUnattendedMode = false;
        unattendedCts?.Cancel();
        unattendedCts?.Dispose();
        unattendedCts = null;
        await SavePersistedStatsAsync();
    }

    private int GetWinCount(List<int> list, int threshold)
    {
        int winCount = 0;
        foreach (int item in list)
        {
            if (item > threshold) winCount++;
        }
        return winCount;
    }
}
